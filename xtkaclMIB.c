/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "xtkaclMIB.h"
#include <time.h>  // current time
#include <sys/sysinfo.h> // get system information(int sysinfo(struct sysinfo *info))
#include <stdint.h> // uint64_t 

#define SIZE_IN_MB 1048576 // The number used for conversion Byte number to higher unit MegaBytes (used type of conversion 1kB == 1024B not 1kB == 1000B )

struct Number {
    int32_t val;
};

struct Number number = { .val = 0 };



/** Initializes the xtkaclMIB module */
void
init_xtkaclMIB(void)
{
    const oid myLogin_oid[] = { 1,3,6,1,3,22,1 };
    const oid myCurrentTime_oid[] = { 1,3,6,1,3,22,2 };
    const oid myNumGetSet_oid[] = { 1,3,6,1,3,22,3 };
    const oid myRAM_oid[] = { 1,3,6,1,3,22,4 };
  
    DEBUGMSGTL(("xtkaclMIB", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("myLogin", handle_myLogin,
                               myLogin_oid, OID_LENGTH(myLogin_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("myCurrentTime", handle_myCurrentTime,
                               myCurrentTime_oid, OID_LENGTH(myCurrentTime_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("myNumGetSet", handle_myNumGetSet,
                               myNumGetSet_oid, OID_LENGTH(myNumGetSet_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("myRAM", handle_myRAM,
                               myRAM_oid, OID_LENGTH(myRAM_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_myLogin(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    // Static used beacause this object is only read-only.   
    static char login[] = "xtkacl00";
    static int  login_size = sizeof(login)-1; 

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, &login, login_size);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_myLogin\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_myCurrentTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    time_t current_time;
    char time_buff[25];
    static int time_format_size = 20; // fixed size of output time format  
    time(&current_time); // get current time calendar time as a object of data type type_t   
    
    // Get string representation of time in GMT time zone +00:00 with RFC-3339 formatting.
    strftime(time_buff,time_format_size+1,"%Y-%m-%dT%H:%M:%SZ", gmtime(&current_time)); // time_format_size + 1 beacuse '\0'
     
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, time_buff, time_format_size);
            break;
        
        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_myCurrentTime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_myNumGetSet(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    ;    
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &number.val, sizeof(number.val)); 
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* or you could use netsnmp_check_vb_type_and_size instead */
            number.val = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( number.val != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, number.val );
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            number.val = *(requests->requestvb->val.integer); //store new value which was accepted by snmpset for agent module  
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_myNumGetSet\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_myRAM(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    struct sysinfo system_info; // declare system info data structure  
    sysinfo(&system_info); // determine system info into sysinfo data stucture
    char sys_buff[30];   // char buffer with fixed size for result value
    memset(sys_buff, 0, sizeof(sys_buff)); // clear buffer  

    uint64_t ram_size_mb = SIZE_IN_MB;   // MAGIC number for B->MB conversion
    uint64_t ram_in_mb = system_info.totalram / ram_size_mb; // compute total ram size in bytes to size in megabytes
    
    sprintf(sys_buff, "%"PRIu64" MB", ram_in_mb); // push value into buffer with unit name of value
    
    /** 
     * Via OCTET STRING are printable characters as '/0',
     * so i decided that i am going to count text size without them). :) 
     */
    int i = 0;
    int text_size = 0;
    while(sys_buff[i] != '\0') {      
        text_size++;
        i++;    
    }

    switch(reqinfo->mode) {

	case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, &sys_buff, sizeof(char) * text_size);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_myRAM\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
